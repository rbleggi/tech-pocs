pipeline {
    agent {
        docker {
            image 'docker:dind'
            args '-u root -v /var/run/docker.sock:/var/run/docker.sock --privileged'
        }
    }
    
    options {
        timeout(time: 15, unit: 'MINUTES')
        disableConcurrentBuilds()
    }
    
    environment {
        DOCKER_IMAGE = 'tech-pocs/java-devops-app'
        DOCKER_TAG = "${BUILD_NUMBER}"
        KUBECONFIG = "/config/kubeconfig.yaml"
        WORKSPACE = "${env.WORKSPACE}/java/devops"
        HELM_CHART_PATH = "${WORKSPACE}/helm/sample-app"
        OPENTOFU_DIR = "${WORKSPACE}/opentofu"
        INFRA_NAMESPACE = "infrastructure"
        APP_NAMESPACE = "applications"
    }

    stages {
        stage('Install Tools') {
            steps {
                echo "Installing required tools"
                sh '''
                # Install required tools in Alpine Linux
                apk update
                apk add --no-cache bash curl maven openjdk21 git
                
                # Set Java home
                export JAVA_HOME=/usr/lib/jvm/java-21-openjdk
                export PATH=$JAVA_HOME/bin:$PATH

                # Install kubectl
                curl -LO "https://dl.k8s.io/release/stable.txt"
                KUBECTL_VERSION=$(cat stable.txt)
                curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
                chmod +x kubectl
                mv kubectl /usr/local/bin/

                # Install Helm
                curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
                chmod 700 get_helm.sh
                ./get_helm.sh

                # Verify installations
                java -version
                mvn --version
                docker --version
                git --version
                kubectl version --client
                helm version
                '''
            }
        }

        stage('Verify Agent') {
            steps {
                echo "Running on agent: ${env.NODE_NAME}"
                echo "This build is NOT running on the built-in node"
                sh 'hostname'
            }
        }
        
        stage('Checkout') {
            steps {
                checkout scm
                sh 'ls -la'
            }
        }
        
        stage('Run Tests') {
            steps {
                echo "Running Maven tests"
                sh '''
                # Execute Maven tests only in the java/devops directory
                cd java/devops
                mvn clean test
                '''
            }
            post {
                failure {
                    echo "Tests failed! Pipeline will stop."
                    error "Test execution failed"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                echo "Building Docker image on agent ${env.NODE_NAME}"
                sh """
                    # Ensure we're in the correct directory where Dockerfile is located
                    cd ${WORKSPACE}
                    ls -la  # Debug: list files to confirm Dockerfile presence
                    docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} -f Dockerfile .
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest
                """
            }
        }
        
        stage('OpenTofu Tests & Provision') {
            steps {
                echo "Running OpenTofu validation tests"
                sh """
                # Ensure we're in the correct directory where OpenTofu files are located
                cd ${OPENTOFU_DIR}
                ls -la  # Debug: list files to confirm OpenTofu files presence

                # Validate OpenTofu configuration
                tofu init
                tofu validate

                # Create plan and ensure it's valid
                tofu plan -out=tfplan

                # Apply infrastructure changes
                tofu apply -auto-approve tfplan

                # Create infrastructure namespace if it doesn't exist
                kubectl --kubeconfig=${KUBECONFIG} create namespace ${INFRA_NAMESPACE} --dry-run=client -o yaml | kubectl --kubeconfig=${KUBECONFIG} apply -f -

                # Create application namespace if it doesn't exist
                kubectl --kubeconfig=${KUBECONFIG} create namespace ${APP_NAMESPACE} --dry-run=client -o yaml | kubectl --kubeconfig=${KUBECONFIG} apply -f -
                """
            }
        }

        stage('Deploy Infrastructure Components') {
            steps {
                echo "Deploying infrastructure components to infrastructure namespace"
                sh """
                # Deploy Prometheus to infrastructure namespace
                helm --kubeconfig=${KUBECONFIG} upgrade --install prometheus ./helm/prometheus \
                    --namespace ${INFRA_NAMESPACE}

                # Deploy Grafana to infrastructure namespace
                helm --kubeconfig=${KUBECONFIG} upgrade --install grafana ./helm/grafana \
                    --namespace ${INFRA_NAMESPACE}

                # Wait for infrastructure components to be ready
                kubectl --kubeconfig=${KUBECONFIG} wait --for=condition=available deployment/prometheus-server --timeout=120s -n ${INFRA_NAMESPACE} || true
                kubectl --kubeconfig=${KUBECONFIG} wait --for=condition=available deployment/grafana --timeout=120s -n ${INFRA_NAMESPACE} || true
                """
            }
        }

        stage('Deploy Application') {
            steps {
                echo "Deploying application with Prometheus integration"
                sh """
                # Check if Kubernetes is accessible
                kubectl --kubeconfig=${KUBECONFIG} get nodes

                # Update or install chart with the new image
                helm --kubeconfig=${KUBECONFIG} upgrade --install java-app ${HELM_CHART_PATH} \
                    --set image.repository=${DOCKER_IMAGE} \
                    --set image.tag=${DOCKER_TAG} \
                    --set prometheus.enabled=true \
                    --namespace ${APP_NAMESPACE} --create-namespace

                # Verify if deployment was successful
                kubectl --kubeconfig=${KUBECONFIG} rollout status deployment/java-app -n ${APP_NAMESPACE}
                """
            }
        }

        stage('Verify Deployment') {
            steps {
                echo "Verifying deployment"
                sh """
                kubectl --kubeconfig=${KUBECONFIG} get all -n ${APP_NAMESPACE}

                # Check if service is responding
                echo "Waiting for service to be available..."
                sleep 10
                kubectl --kubeconfig=${KUBECONFIG} get svc -n ${APP_NAMESPACE}

                # Verify Prometheus scraping configuration for application
                echo "Checking for Prometheus service monitor..."
                kubectl --kubeconfig=${KUBECONFIG} get servicemonitor -n ${APP_NAMESPACE} || echo "ServiceMonitor not found - verify Prometheus integration"
                """
            }
        }

        stage('Cleanup') {
            steps {
                echo "Cleaning up resources"
                sh """
                    docker system prune -f
                """
            }
        }
    }
    
    post {
        always {
            echo "Build completed on agent: ${env.NODE_NAME}"
        }
        success {
            echo "Build and deployment succeeded!"
        }
        failure {
            echo "Build or deployment failed!"
        }
    }
}
