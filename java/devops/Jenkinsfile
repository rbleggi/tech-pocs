pipeline {
    agent {
        docker {
            image 'docker:dind'
            args '-u root -v /var/run/docker.sock:/var/run/docker.sock --privileged --add-host=k3s:host-gateway'
        }
    }
    
    options {
        timeout(time: 15, unit: 'MINUTES')
        disableConcurrentBuilds()
    }
    
    environment {
        DOCKER_IMAGE = 'tech-pocs/java-devops-app'
        DOCKER_TAG = "${BUILD_NUMBER}"
        WORKSPACE = "${env.WORKSPACE}/java/devops"
        KUBECONFIG = "${WORKSPACE}/k3s/kubeconfig.yaml"
        HELM_CHART_PATH = "${WORKSPACE}/helm/sample-app"
        OPENTOFU_DIR = "${WORKSPACE}/opentofu"
        INFRA_NAMESPACE = "infrastructure"
        APP_NAMESPACE = "applications"
    }

    stages {
        stage('Install Tools') {
            steps {
                echo "Installing required tools"
                sh '''
                # Install required tools in Alpine Linux
                apk update
                apk add --no-cache bash curl maven openjdk21 git
                
                # Set Java home
                export JAVA_HOME=/usr/lib/jvm/java-21-openjdk
                export PATH=$JAVA_HOME/bin:$PATH

                # Install kubectl
                curl -LO "https://dl.k8s.io/release/stable.txt"
                KUBECTL_VERSION=$(cat stable.txt)
                curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
                chmod +x kubectl
                mv kubectl /usr/local/bin/

                # Install Helm
                curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
                chmod 700 get_helm.sh
                ./get_helm.sh

                # Install OpenTofu
                curl -L -o opentofu.zip https://github.com/opentofu/opentofu/releases/download/v1.6.0/tofu_1.6.0_linux_amd64.zip
                # Use -o flag to overwrite files without prompting
                unzip -o opentofu.zip
                chmod +x tofu
                mv tofu /usr/local/bin/
                rm -f opentofu.zip

                # Verify installations
                java -version
                mvn --version
                docker --version
                git --version
                kubectl version --client
                helm version
                tofu version
                '''
            }
        }

        stage('Verify Agent') {
            steps {
                echo "Running on agent: ${env.NODE_NAME}"
                echo "This build is NOT running on the built-in node"
                sh 'hostname'
            }
        }
        
        stage('Checkout') {
            steps {
                checkout scm
                sh 'ls -la'
            }
        }
        
        stage('Run Tests') {
            steps {
                echo "Running Maven tests"
                sh '''
                # Execute Maven tests only in the java/devops directory
                cd java/devops
                mvn clean test
                '''
            }
            post {
                failure {
                    echo "Tests failed! Pipeline will stop."
                    error "Test execution failed"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                echo "Building Docker image on agent ${env.NODE_NAME}"
                sh """
                    # Ensure we're in the correct directory where Dockerfile is located
                    cd ${WORKSPACE}
                    ls -la  # Debug: list files to confirm Dockerfile presence
                    docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} -f Dockerfile .
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest
                """
            }
        }
        
        stage('Setup Kubernetes Access') {
            steps {
                echo "Setting up access to Kubernetes cluster"
                sh """
                    # Install tools needed for network diagnostics
                    apk add --no-cache curl iputils bind-tools netcat-openbsd jq

                    # List network info and DNS resolution
                    echo "Network information:"
                    ip addr

                    # Check /etc/hosts
                    echo "Current /etc/hosts file:"
                    cat /etc/hosts

                    # Check if k3s name resolves
                    echo "Testing k3s hostname resolution:"
                    getent hosts k3s || echo "Cannot resolve k3s hostname"

                    # Check if localhost:6443 is accessible
                    echo "Testing localhost:6443 connection:"
                    nc -zv localhost 6443 || echo "Cannot connect to localhost:6443"

                    # Check if host.docker.internal:6443 is accessible
                    echo "Testing host.docker.internal:6443 connection:"
                    nc -zv host.docker.internal 6443 || echo "Cannot connect to host.docker.internal:6443"

                    # Using host-gateway (Docker's internal IP for the host)
                    echo "Testing host-gateway:6443 connection:"
                    nc -zv host-gateway 6443 || echo "Cannot connect to host-gateway:6443"

                    # Create a directory for the modified kubeconfig
                    mkdir -p \${WORKSPACE}/k3s-modified

                    # Modify kubeconfig to use host-gateway instead of k3s
                    echo "Creating modified kubeconfig with host-gateway"
                    cat ${KUBECONFIG} | sed 's|https://k3s:6443|https://host-gateway:6443|g' > \${WORKSPACE}/k3s-modified/kubeconfig.yaml

                    # Debug the modified config
                    echo "Modified kubeconfig server setting:"
                    grep "server:" \${WORKSPACE}/k3s-modified/kubeconfig.yaml

                    # Test the new kubeconfig
                    echo "Testing connection to K3s with modified kubeconfig:"
                    kubectl --kubeconfig=\${WORKSPACE}/k3s-modified/kubeconfig.yaml cluster-info || echo "Failed to connect to K3s"
                """

                script {
                    env.KUBECONFIG = "${WORKSPACE}/k3s-modified/kubeconfig.yaml"
                    echo "Set KUBECONFIG to ${env.KUBECONFIG}"
                }
            }
        }

        stage('OpenTofu Tests & Provision') {
            steps {
                echo "Running OpenTofu validation tests"
                sh """
                # Ensure we're in the correct directory where OpenTofu files are located
                cd ${OPENTOFU_DIR}
                ls -la  # Debug: list files to confirm OpenTofu files presence

                # Validate OpenTofu configuration
                tofu init
                tofu validate

                # Create plan and ensure it's valid
                tofu plan -var="kubeconfig_path=${KUBECONFIG}" -out=tfplan

                # Apply infrastructure changes
                tofu apply -auto-approve tfplan
                """
            }
        }

        stage('Deploy Infrastructure Components') {
            steps {
                echo "Deploying infrastructure components to infrastructure namespace"
                sh """
                # Deploy Prometheus to infrastructure namespace
                helm --kubeconfig=${KUBECONFIG} upgrade --install prometheus ./helm/prometheus \
                    --namespace ${INFRA_NAMESPACE}

                # Deploy Grafana to infrastructure namespace
                helm --kubeconfig=${KUBECONFIG} upgrade --install grafana ./helm/grafana \
                    --namespace ${INFRA_NAMESPACE}

                # Wait for infrastructure components to be ready
                kubectl --kubeconfig=${KUBECONFIG} wait --for=condition=available deployment/prometheus-server --timeout=120s -n ${INFRA_NAMESPACE} || true
                kubectl --kubeconfig=${KUBECONFIG} wait --for=condition=available deployment/grafana --timeout=120s -n ${INFRA_NAMESPACE} || true
                """
            }
        }

        stage('Deploy Application') {
            steps {
                echo "Deploying application with Prometheus integration"
                sh """
                # Check if Kubernetes is accessible
                kubectl --kubeconfig=${KUBECONFIG} get nodes

                # Update or install chart with the new image
                helm --kubeconfig=${KUBECONFIG} upgrade --install java-app ${HELM_CHART_PATH} \
                    --set image.repository=${DOCKER_IMAGE} \
                    --set image.tag=${DOCKER_TAG} \
                    --set prometheus.enabled=true \
                    --namespace ${APP_NAMESPACE} --create-namespace

                # Verify if deployment was successful
                kubectl --kubeconfig=${KUBECONFIG} rollout status deployment/java-app -n ${APP_NAMESPACE}
                """
            }
        }

        stage('Verify Deployment') {
            steps {
                echo "Verifying deployment"
                sh """
                kubectl --kubeconfig=${KUBECONFIG} get all -n ${APP_NAMESPACE}

                # Check if service is responding
                echo "Waiting for service to be available..."
                sleep 10
                kubectl --kubeconfig=${KUBECONFIG} get svc -n ${APP_NAMESPACE}

                # Verify Prometheus scraping configuration for application
                echo "Checking for Prometheus service monitor..."
                kubectl --kubeconfig=${KUBECONFIG} get servicemonitor -n ${APP_NAMESPACE} || echo "ServiceMonitor not found - verify Prometheus integration"
                """
            }
        }

        stage('Cleanup') {
            steps {
                echo "Cleaning up resources"
                sh """
                    docker system prune -f
                """
            }
        }
    }
    
    post {
        always {
            echo "Build completed on agent: ${env.NODE_NAME}"
        }
        success {
            echo "Build and deployment succeeded!"
        }
        failure {
            echo "Build or deployment failed!"
        }
    }
}
