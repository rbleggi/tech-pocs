pipeline {
    agent {
        docker {
            image 'docker:latest'
            args '-v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker'
        }
    }
    
    options {
        timeout(time: 15, unit: 'MINUTES')
        disableConcurrentBuilds()
    }
    
    environment {
        DOCKER_IMAGE = 'tech-pocs/java-devops-app'
        DOCKER_TAG = "${BUILD_NUMBER}"
        KUBECONFIG = "/config/kubeconfig.yaml"
        HELM_CHART_PATH = "./helm/sample-app"
        OPENTOFU_DIR = "./opentofu"
    }

    stages {
        stage('Verify Agent') {
            steps {
                echo "Running on agent: ${env.NODE_NAME}"
                echo "This build is NOT running on the built-in node"
                sh 'hostname'
                sh 'java -version'
            }
        }
        
        stage('Checkout') {
            steps {
                checkout scm
                sh 'ls -la'
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo "Building Docker image on agent ${env.NODE_NAME}"
                sh """
                    docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} -f Dockerfile .
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest
                """
            }
        }
        
        stage('Run Tests') {
            steps {
                echo "Running tests"
                sh 'ls -la src/test'
                sh '''
                # Here you can run unit or integration tests
                echo "Running tests for Java application"
                # If you need Maven or Gradle, adjust as necessary
                '''
            }
        }
        
        stage('OpenTofu Provision') {
            steps {
                echo "Provisioning infrastructure with OpenTofu"
                sh """
                cd ${OPENTOFU_DIR}
                tofu init
                tofu validate
                tofu plan -out=tfplan
                tofu apply -auto-approve tfplan
                """
            }
        }

        stage('Helm Deploy') {
            steps {
                echo "Deploying application with Helm"
                sh """
                # Check if Kubernetes is accessible
                kubectl --kubeconfig=${KUBECONFIG} get nodes

                # Update or install chart with the new image
                helm --kubeconfig=${KUBECONFIG} upgrade --install java-app ${HELM_CHART_PATH} \
                    --set image.repository=${DOCKER_IMAGE} \
                    --set image.tag=${DOCKER_TAG} \
                    --namespace applications --create-namespace

                # Verify if deployment was successful
                kubectl --kubeconfig=${KUBECONFIG} rollout status deployment/java-app -n applications
                """
            }
        }

        stage('Verify Deployment') {
            steps {
                echo "Verifying deployment"
                sh """
                kubectl --kubeconfig=${KUBECONFIG} get all -n applications

                # Check if service is responding
                echo "Waiting for service to be available..."
                sleep 10
                kubectl --kubeconfig=${KUBECONFIG} get svc -n applications
                """
            }
        }
    }
    
    post {
        always {
            echo "Build completed on agent: ${env.NODE_NAME}"
            sh """
                # Cleanup of resources not needed
                docker system prune -f
            """
        }
        success {
            echo "Build and deployment succeeded!"
        }
        failure {
            echo "Build or deployment failed!"
        }
    }
}
