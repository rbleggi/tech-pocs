pipeline {
    agent {
        docker {
            image 'docker:20.10-dind'
            args '-u root -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin:/usr/bin --privileged'
        }
    }
    
    options {
        timeout(time: 15, unit: 'MINUTES')
        disableConcurrentBuilds()
    }
    
    environment {
        DOCKER_IMAGE = 'tech-pocs/java-devops-app'
        DOCKER_TAG = "${BUILD_NUMBER}"
        KUBECONFIG = "/config/kubeconfig.yaml"
        HELM_CHART_PATH = "./helm/sample-app"
        OPENTOFU_DIR = "./opentofu"
        INFRA_NAMESPACE = "infrastructure"
        APP_NAMESPACE = "applications"
    }

    stages {
        stage('Verify Agent') {
            steps {
                echo "Running on agent: ${env.NODE_NAME}"
                echo "This build is NOT running on the built-in node"
                sh 'hostname'
                sh 'apk add --no-cache openjdk17-jre maven kubectl helm'
                sh 'java -version'
            }
        }
        
        stage('Checkout') {
            steps {
                checkout scm
                sh 'ls -la'
            }
        }
        
        stage('Run Tests') {
            steps {
                echo "Running Maven tests"
                sh '''
                # Execute Maven tests
                mvn clean test
                '''
            }
            post {
                failure {
                    echo "Tests failed! Pipeline will stop."
                    error "Test execution failed"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                echo "Building Docker image on agent ${env.NODE_NAME}"
                sh """
                    docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} -f Dockerfile .
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest
                """
            }
        }
        
        stage('OpenTofu Tests & Provision') {
            steps {
                echo "Running OpenTofu validation tests"
                sh """
                cd ${OPENTOFU_DIR}
                # Validate OpenTofu configuration
                tofu init
                tofu validate

                # Create plan and ensure it's valid
                tofu plan -out=tfplan

                # Apply infrastructure changes
                tofu apply -auto-approve tfplan

                # Create infrastructure namespace if it doesn't exist
                kubectl --kubeconfig=${KUBECONFIG} create namespace ${INFRA_NAMESPACE} --dry-run=client -o yaml | kubectl --kubeconfig=${KUBECONFIG} apply -f -

                # Create application namespace if it doesn't exist
                kubectl --kubeconfig=${KUBECONFIG} create namespace ${APP_NAMESPACE} --dry-run=client -o yaml | kubectl --kubeconfig=${KUBECONFIG} apply -f -
                """
            }
        }

        stage('Deploy Infrastructure Components') {
            steps {
                echo "Deploying infrastructure components to infrastructure namespace"
                sh """
                # Deploy Prometheus to infrastructure namespace
                helm --kubeconfig=${KUBECONFIG} upgrade --install prometheus ./helm/prometheus \
                    --namespace ${INFRA_NAMESPACE}

                # Deploy Grafana to infrastructure namespace
                helm --kubeconfig=${KUBECONFIG} upgrade --install grafana ./helm/grafana \
                    --namespace ${INFRA_NAMESPACE}

                # Wait for infrastructure components to be ready
                kubectl --kubeconfig=${KUBECONFIG} wait --for=condition=available deployment/prometheus-server --timeout=120s -n ${INFRA_NAMESPACE} || true
                kubectl --kubeconfig=${KUBECONFIG} wait --for=condition=available deployment/grafana --timeout=120s -n ${INFRA_NAMESPACE} || true
                """
            }
        }

        stage('Deploy Application') {
            steps {
                echo "Deploying application with Prometheus integration"
                sh """
                # Check if Kubernetes is accessible
                kubectl --kubeconfig=${KUBECONFIG} get nodes

                # Update or install chart with the new image
                helm --kubeconfig=${KUBECONFIG} upgrade --install java-app ${HELM_CHART_PATH} \
                    --set image.repository=${DOCKER_IMAGE} \
                    --set image.tag=${DOCKER_TAG} \
                    --set prometheus.enabled=true \
                    --namespace ${APP_NAMESPACE} --create-namespace

                # Verify if deployment was successful
                kubectl --kubeconfig=${KUBECONFIG} rollout status deployment/java-app -n ${APP_NAMESPACE}
                """
            }
        }

        stage('Verify Deployment') {
            steps {
                echo "Verifying deployment"
                sh """
                kubectl --kubeconfig=${KUBECONFIG} get all -n ${APP_NAMESPACE}

                # Check if service is responding
                echo "Waiting for service to be available..."
                sleep 10
                kubectl --kubeconfig=${KUBECONFIG} get svc -n ${APP_NAMESPACE}

                # Verify Prometheus scraping configuration for application
                echo "Checking for Prometheus service monitor..."
                kubectl --kubeconfig=${KUBECONFIG} get servicemonitor -n ${APP_NAMESPACE} || echo "ServiceMonitor not found - verify Prometheus integration"
                """
            }
        }

        stage('Cleanup') {
            steps {
                echo "Cleaning up resources"
                sh """
                    docker system prune -f
                """
            }
        }
    }
    
    post {
        always {
            echo "Build completed on agent: ${env.NODE_NAME}"
        }
        success {
            echo "Build and deployment succeeded!"
        }
        failure {
            echo "Build or deployment failed!"
        }
    }
}
